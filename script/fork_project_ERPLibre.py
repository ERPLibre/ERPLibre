#!./.venv/bin/python
import argparse
import logging
import os
import sys

import git
from git import Repo

new_path = os.path.normpath(os.path.join(os.path.dirname(__file__), ".."))
sys.path.append(new_path)

from script.git_tool import GitTool

_logger = logging.getLogger(__name__)
CST_EL_GITHUB_TOKEN = "EL_GITHUB_TOKEN"


def get_config():
    """Parse command line arguments, extracting the config file name,
    returning the union of config file and command line arguments

    :return: dict of config file settings and command line arguments
    """
    config = GitTool.get_project_config()

    # TODO update description
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description="""\
""",
        epilog="""\
""",
    )
    parser.add_argument(
        "-d",
        "--dir",
        dest="dir",
        default="./",
        help="Path of repo to change remote, including submodule.",
    )
    parser.add_argument(
        "--organization",
        dest="organization",
        default="ERPLibre",
        help="Choose organization to fork and change all repo.",
    )
    parser.add_argument(
        "--skip_fork",
        action="store_true",
        help="Ignore fork to generate only manifest.",
    )
    parser.add_argument(
        "-f", "--force", action="store_true", help="Force rewrite remote."
    )
    parser.add_argument(
        "--fast", action="store_true", help="Ignore if repo already exist."
    )
    parser.add_argument(
        "--github_token",
        dest="github_token",
        default=config.get(CST_EL_GITHUB_TOKEN),
        help="GitHub token generated by user",
    )
    args = parser.parse_args()
    return args


def main():
    config = get_config()
    github_token = config.github_token
    git_tool = GitTool()
    root_repo = Repo(config.dir)

    if not github_token and not config.skip_fork:
        raise ValueError("Missing github_token")

    organization_name = config.organization
    lst_repo = git_tool.get_source_repo_addons(
        repo_path=config.dir, add_repo_root=True
    )
    lst_repo_organization = [
        git_tool.get_transformed_repo_info_from_url(
            a.get("url"),
            repo_path=config.dir,
            organization_force=organization_name,
            is_submodule=a.get("is_submodule"),
            sub_path=a.get("sub_path"),
            revision=a.get("revision"),
            clone_depth=a.get("clone_depth"),
        )
        for a in lst_repo
    ]

    if not config.skip_fork:
        i = 0
        total = len(lst_repo)
        for repo in lst_repo:
            i += 1
            print(f"Nb element {i}/{total} - {repo.get('project_name')}")
            if (
                config.fast
                and repo.get("is_submodule")
                and os.path.isdir(repo.get("path"))
            ):
                continue
            url = repo.get("url")

            try:
                working_repo = Repo(repo.get("relative_path"))
            except git.exc.NoSuchPathError:
                # Check to fork
                # repo_info = git_tool.get_transformed_repo_info_from_url(
                #     url, organization_force="ERPLibre",
                #     is_submodule=repo.get("is_submodule"),
                #     sub_path=repo.get("sub_path"))
                git_tool.fork_repo(
                    upstream_url=url,
                    github_token=github_token,
                    organization_name="ERPLibre",
                )
                repo_info = git_tool.get_transformed_repo_info_from_url(
                    url,
                    organization_force=organization_name,
                    is_submodule=repo.get("is_submodule"),
                    sub_path=repo.get("sub_path"),
                )
                git_tool.fork_repo(
                    upstream_url=url,
                    github_token=github_token,
                    organization_name=organization_name,
                )

                # git_tool.add_and_fetch_remote(repo_info, root_repo=root_repo)
                continue

            dct_remote_name = {a.name: a for a in working_repo.remotes}
            remote_origin = dct_remote_name.get("origin")
            remote_erplibre = dct_remote_name.get("ERPLibre")
            remote_organization = dct_remote_name.get(organization_name)

            if not remote_erplibre:
                repo_info = git_tool.get_transformed_repo_info_from_url(
                    url,
                    organization_force="ERPLibre",
                    is_submodule=repo.get("is_submodule"),
                    sub_path=repo.get("sub_path"),
                )
                # git_tool.add_and_fetch_remote(repo_info)

            git_tool.fork_repo(
                url,
                github_token,
                organization_name=organization_name,
            )

            repo_info = git_tool.get_transformed_repo_info_from_url(
                url,
                organization_force=organization_name,
                is_submodule=repo.get("is_submodule"),
                sub_path=repo.get("sub_path"),
            )
            if remote_origin:
                working_repo.git.remote("remove", "origin")
            repo_info.organization = "origin"
            # try:
            #     git_tool.add_and_fetch_remote(repo_info, root_repo=root_repo)
            # except Exception as e:
            #     print(e)
            if config.force and remote_organization:
                working_repo.git.remote("remove", organization_name)

            repo_info.organization = organization_name
            # git_tool.add_and_fetch_remote(repo_info)

    # Update origin to new repo
    # git_tool.generate_git_modules(lst_repo_organization, repo_path=config.dir)
    git_tool.generate_repo_manifest(
        lst_repo_organization, output=f"{config.dir}manifest/default.dev.xml"
    )
    git_tool.generate_generate_config()


if __name__ == "__main__":
    main()
